// Generated by leapfrog cpp_generation: do not edit by hand
// This file is automatically generated. Do not edit this file. If you want to make changes
// edit leapfrog json files in `cpp_generation/modelSchemas` and run `uv run ./src/main.py` inside
// the `cpp_generation` folder.

#pragma once

#include "config.hpp"
#include "../options.hpp"

namespace leapfrog {

enum Language {
  Cpp,
  R,
  C,
  Py
};

namespace internal {

template<Language L, typename real_type, MV ModelVariant>
struct DpAdapter;

template<Language L, typename real_type, MV ModelVariant>
struct HaAdapter;

template<Language L, typename real_type, MV ModelVariant>
struct HcAdapter;

template<Language L, typename ...Ts>
struct ConfigMixer;

template<Language L, typename real_type, MV ModelVariant>
struct ConfigMixer<L, real_type, ModelVariant> {
  struct Pars {};

  template<typename... Args>
  static Pars get_pars(Args&&... args) {
    Pars p = {}; return p;
  }

  struct Intermediate {
    void reset() {};
  };

  struct State {
    void reset() {};
  };

  template<typename... Args>
  static State get_initial_state(Args&&... args) {
    State s = {}; return s;
  }

  struct OutputState {
    OutputState(int output_years) {};
    void save_state(const size_t i, const auto &state) {};
  };

  static int get_build_output_size(int prev_size) {
    return prev_size;
  };

  template<typename... Args>
  static int build_output(int index, Args&&... args) {
    return index;
  }

  template<typename... Args>
  static int build_output_single_year(int index, Args&&... args) {
    return index;
  }
};

template<Language L, typename real_type, MV ModelVariant, typename Config, typename ...Ts>
struct ConfigMixer<L, real_type, ModelVariant, Pair<false, Config>, Ts...> : public ConfigMixer<L, real_type, ModelVariant, Ts...> {};


template<Language L, typename real_type1, MV ModelVariant1, typename ...Ts>
struct ConfigMixer<L, real_type1, ModelVariant1, Pair<true, DpConfig<real_type1, ModelVariant1>>, Ts...> {
  using real_type = real_type1;
  using ModelVariant = ModelVariant1;
  using CurrConfig = DpConfig<real_type, ModelVariant>;
  using Adapter = DpAdapter<L, real_type, ModelVariant>;
  using NextConfigMixer = ConfigMixer<L, real_type, ModelVariant, Ts...>;
  using SS = SSMixed<ModelVariant>;

  struct Pars: public NextConfigMixer::Pars {
    typename CurrConfig::Pars dp;
  };

  template<typename... Args>
  static Pars get_pars(Args&&... args) {
    Pars p = {
      NextConfigMixer::get_pars(std::forward<Args>(args)...),
      Adapter::get_pars(std::forward<Args>(args)...)
    };
    return p;
  }

  struct Intermediate: public NextConfigMixer::Intermediate {
    typename CurrConfig::Intermediate dp;

    Intermediate():
      NextConfigMixer::Intermediate(),
      dp() {};

    void reset() {
      NextConfigMixer::Intermediate::reset();
      dp.reset();
    };
  };

  struct State: public NextConfigMixer::State {
    typename CurrConfig::State dp;

    void reset() {
      NextConfigMixer::State::reset();
      dp.reset();
    };
  };

  template<typename... Args>
  static State get_initial_state(Args&&... args) {
    return {
      NextConfigMixer::get_initial_state(std::forward<Args>(args)...),
      Adapter::get_initial_state(std::forward<Args>(args)...)
    };
  }

  struct OutputState: public NextConfigMixer::OutputState {
    typename CurrConfig::OutputState dp;

    OutputState(int output_years):
      NextConfigMixer::OutputState(output_years),
      dp(output_years) {};

    void save_state(const size_t i, const State &state) {
      NextConfigMixer::OutputState::save_state(i, state);
      dp.save_state(i, state.dp);
    };
  };

  static int get_build_output_size(int prev_size) {
    int curr_size = NextConfigMixer::get_build_output_size(prev_size);
    return CurrConfig::get_build_output_size(curr_size);
  };

  template<typename... Args>
  static int build_output(int index, OutputState& state, Args&&... args) {
    int new_index = Adapter::build_output(index, state.dp, std::forward<Args>(args)...);
    return NextConfigMixer::build_output(new_index, state, std::forward<Args>(args)...);
  }

  template<typename... Args>
  static int build_output_single_year(int index, State& state, Args&&... args) {
    int new_index = Adapter::build_output_single_year(index, state.dp, std::forward<Args>(args)...);
    return NextConfigMixer::build_output_single_year(new_index, state, std::forward<Args>(args)...);
  }

  struct Args {
    int t;
    const Pars& pars;
    const State& state_curr;
    State& state_next;
    Intermediate& intermediate;
    const Options<real_type>& opts;
  };
};

template<Language L, typename real_type1, MV ModelVariant1, typename ...Ts>
struct ConfigMixer<L, real_type1, ModelVariant1, Pair<true, HaConfig<real_type1, ModelVariant1>>, Ts...> {
  using real_type = real_type1;
  using ModelVariant = ModelVariant1;
  using CurrConfig = HaConfig<real_type, ModelVariant>;
  using Adapter = HaAdapter<L, real_type, ModelVariant>;
  using NextConfigMixer = ConfigMixer<L, real_type, ModelVariant, Ts...>;
  using SS = SSMixed<ModelVariant>;

  struct Pars: public NextConfigMixer::Pars {
    typename CurrConfig::Pars ha;
  };

  template<typename... Args>
  static Pars get_pars(Args&&... args) {
    Pars p = {
      NextConfigMixer::get_pars(std::forward<Args>(args)...),
      Adapter::get_pars(std::forward<Args>(args)...)
    };
    return p;
  }

  struct Intermediate: public NextConfigMixer::Intermediate {
    typename CurrConfig::Intermediate ha;

    Intermediate():
      NextConfigMixer::Intermediate(),
      ha() {};

    void reset() {
      NextConfigMixer::Intermediate::reset();
      ha.reset();
    };
  };

  struct State: public NextConfigMixer::State {
    typename CurrConfig::State ha;

    void reset() {
      NextConfigMixer::State::reset();
      ha.reset();
    };
  };

  template<typename... Args>
  static State get_initial_state(Args&&... args) {
    return {
      NextConfigMixer::get_initial_state(std::forward<Args>(args)...),
      Adapter::get_initial_state(std::forward<Args>(args)...)
    };
  }

  struct OutputState: public NextConfigMixer::OutputState {
    typename CurrConfig::OutputState ha;

    OutputState(int output_years):
      NextConfigMixer::OutputState(output_years),
      ha(output_years) {};

    void save_state(const size_t i, const State &state) {
      NextConfigMixer::OutputState::save_state(i, state);
      ha.save_state(i, state.ha);
    };
  };

  static int get_build_output_size(int prev_size) {
    int curr_size = NextConfigMixer::get_build_output_size(prev_size);
    return CurrConfig::get_build_output_size(curr_size);
  };

  template<typename... Args>
  static int build_output(int index, OutputState& state, Args&&... args) {
    int new_index = Adapter::build_output(index, state.ha, std::forward<Args>(args)...);
    return NextConfigMixer::build_output(new_index, state, std::forward<Args>(args)...);
  }

  template<typename... Args>
  static int build_output_single_year(int index, State& state, Args&&... args) {
    int new_index = Adapter::build_output_single_year(index, state.ha, std::forward<Args>(args)...);
    return NextConfigMixer::build_output_single_year(new_index, state, std::forward<Args>(args)...);
  }

  struct Args {
    int t;
    const Pars& pars;
    const State& state_curr;
    State& state_next;
    Intermediate& intermediate;
    const Options<real_type>& opts;
  };
};

template<Language L, typename real_type1, MV ModelVariant1, typename ...Ts>
struct ConfigMixer<L, real_type1, ModelVariant1, Pair<true, HcConfig<real_type1, ModelVariant1>>, Ts...> {
  using real_type = real_type1;
  using ModelVariant = ModelVariant1;
  using CurrConfig = HcConfig<real_type, ModelVariant>;
  using Adapter = HcAdapter<L, real_type, ModelVariant>;
  using NextConfigMixer = ConfigMixer<L, real_type, ModelVariant, Ts...>;
  using SS = SSMixed<ModelVariant>;

  struct Pars: public NextConfigMixer::Pars {
    typename CurrConfig::Pars hc;
  };

  template<typename... Args>
  static Pars get_pars(Args&&... args) {
    Pars p = {
      NextConfigMixer::get_pars(std::forward<Args>(args)...),
      Adapter::get_pars(std::forward<Args>(args)...)
    };
    return p;
  }

  struct Intermediate: public NextConfigMixer::Intermediate {
    typename CurrConfig::Intermediate hc;

    Intermediate():
      NextConfigMixer::Intermediate(),
      hc() {};

    void reset() {
      NextConfigMixer::Intermediate::reset();
      hc.reset();
    };
  };

  struct State: public NextConfigMixer::State {
    typename CurrConfig::State hc;

    void reset() {
      NextConfigMixer::State::reset();
      hc.reset();
    };
  };

  template<typename... Args>
  static State get_initial_state(Args&&... args) {
    return {
      NextConfigMixer::get_initial_state(std::forward<Args>(args)...),
      Adapter::get_initial_state(std::forward<Args>(args)...)
    };
  }

  struct OutputState: public NextConfigMixer::OutputState {
    typename CurrConfig::OutputState hc;

    OutputState(int output_years):
      NextConfigMixer::OutputState(output_years),
      hc(output_years) {};

    void save_state(const size_t i, const State &state) {
      NextConfigMixer::OutputState::save_state(i, state);
      hc.save_state(i, state.hc);
    };
  };

  static int get_build_output_size(int prev_size) {
    int curr_size = NextConfigMixer::get_build_output_size(prev_size);
    return CurrConfig::get_build_output_size(curr_size);
  };

  template<typename... Args>
  static int build_output(int index, OutputState& state, Args&&... args) {
    int new_index = Adapter::build_output(index, state.hc, std::forward<Args>(args)...);
    return NextConfigMixer::build_output(new_index, state, std::forward<Args>(args)...);
  }

  template<typename... Args>
  static int build_output_single_year(int index, State& state, Args&&... args) {
    int new_index = Adapter::build_output_single_year(index, state.hc, std::forward<Args>(args)...);
    return NextConfigMixer::build_output_single_year(new_index, state, std::forward<Args>(args)...);
  }

  struct Args {
    int t;
    const Pars& pars;
    const State& state_curr;
    State& state_next;
    Intermediate& intermediate;
    const Options<real_type>& opts;
  };
};

template<Language L, typename real_type, MV ModelVariant>
using Config = ConfigMixer<
  L, real_type, ModelVariant,
  Pair<ModelVariant::run_demographic_projection, DpConfig<real_type, ModelVariant>>,
  Pair<ModelVariant::run_hiv_simulation, HaConfig<real_type, ModelVariant>>,
  Pair<ModelVariant::run_child_model, HcConfig<real_type, ModelVariant>>
>;

} // namespace internal
} // namespace leapfrog
