#' Generate C++ for passing output from model fit into R
#'
#' This generates using metadata from `src/model_output.yml`
#'
#' @param dest The destination to write generated code to.
#'
#' @return Nothing, called to generate code in src dir
#' @keywords internal
generate_output_interface <- function(dest) {

  template <- readLines(frogger_file("r_interface/model_output.hpp.in"))
  outputs <- yaml::read_yaml(
    frogger_file("r_interface/model_outputs.yml"))$outputs

  for (i in seq_along(outputs)) {
    assert_names(outputs[[i]],
                 c("output_name", "state_name", "r_type", "dimensions"),
                 c())
    outputs[[i]]$dimensions <- parse_dimensions(outputs[[i]]$dimensions)
  }

  initialise_r_memory <- vcapply(outputs, generate_initialise_r_memory)
  initialise_r_memory <- paste(initialise_r_memory, collapse = "\n")
  set_r_dimensions <- vcapply(outputs, generate_set_r_dimensions)
  set_r_dimensions <- paste(set_r_dimensions, collapse = "\n")
  copy_data <- vcapply(outputs, generate_copy_data)
  copy_data <- paste(copy_data, collapse = "\n")
  return_output <- vcapply(outputs, generate_return)
  return_output <- paste0("return Rcpp::List::create(\n",
                          paste(return_output, collapse = ",\n"),
                          ");")
  header <- paste0(
    "// ========= DO NOT EDIT =========\n",
    "// This file is automatically generated. Do not edit this file. If you ",
    "want to make changes\n// edit `model_output.hpp.in` and run ",
    "`./scripts/generate` to regenerate.")

  generated_code <- glue::glue(paste(template, collapse = "\n"),
                               .open = "{{", .close = "}}")
  writeLines(generated_code, dest)
  invisible(TRUE)
}

parse_dimensions <- function(dimensions) {
  vcapply(dimensions, function(dim) {
    if (dim != "output_years") {
      ## All other sizes are part of the state space struct
      dim <- paste0("ss.", dim)
    }
    dim
  })
}

generate_initialise_r_memory <- function(output) {
  dimensions <- paste(output$dimensions, collapse = " * ")
  sprintf("  Rcpp::NumericVector r_%s(%s);", output$output_name, dimensions)
}

generate_set_r_dimensions <- function(output) {
  dimensions <- paste(output$dimensions, collapse = ", ")
  sprintf("  r_%s.attr(\"dim\") = Rcpp::NumericVector::create(%s);",
          output$output_name, dimensions)
}

generate_copy_data <- function(output) {
  sprintf("  std::copy_n(state.%s.data(), state.%s.size(), %s(r_%s));",
          output$state_name, output$state_name, output$r_type,
          output$output_name)
}

generate_return <- function(output) {
  dimensions <- paste(output$dimensions, collapse = ", ")
  sprintf("    Rcpp::_[\"%s\"] = r_%s",
          output$output_name, output$output_name)
}


#' Generate C++ for passing input data in model fit
#'
#' This generates using metadata from `src/model_inputs.yml`
#'
#' @param dest The destination to write generated code to.
#'
#' @return Nothing, called to generate code in src dir
#' @keywords internal
generate_input_interface <- function(dest) {

  template <- readLines(frogger_file("r_interface/model_input.hpp.in"))
  inputs <- yaml::read_yaml(
    frogger_file("r_interface/model_input.yml"))$inputs

  for (i in seq_along(inputs)) {
    assert_names(inputs[[i]],
                 c("output_name", "state_name", "type", "dimensions"),
                 c("convert_base"))
    inputs[[i]]$dimensions <- parse_dimensions(inputs[[i]]$dimensions)
  }

  parse_data <- vcapply(inputs, generate_parse_data)
  parse_data <- paste(parse_data, collapse = "\n")
  header <- paste0(
    "// ========= DO NOT EDIT =========\n",
    "// This file is automatically generated. Do not edit this file. If you ",
    "want to make changes\n// edit `model_input.hpp.in` and run ",
    "`./scripts/generate` to regenerate.")

  generated_code <- glue::glue(paste(template, collapse = "\n"),
                               .open = "{{", .close = "}}")
  writeLines(generated_code, dest)
  invisible(TRUE)
}

generate_parse_data <- function(input) {
  dimensions <- paste(input$dimensions, collapse = ", ")
  n_dims <- length(input$dimensions)
  out <- sprintf(
    "  const leapfrog::TensorMap%s<%s> %s = parse_data<%s>(data, \"%s\", %s);",
    n_dims, input$type, input$param_name, input$type,
    input$input_name, dimensions)
  if (!is.null(input$convert_base) && input$convert_base) {
    out <- c(out, "")
  }
  out
}
