#' Generate C++ for passing output from model fit into R
#'
#' This generates using metadata from `src/model_output.yml`
#'
#' @param dest The destination to write generated code to.
#'
#' @return Nothing, called to generate code in src dir
#' @keywords internal
generate_output_interface <- function(dest) {

  template <- readLines(frogger_file("cpp_generation/model_output.hpp.in"))
  output_file <- "model_output.csv"
  outputs <- utils::read.csv(frogger_file("cpp_generation", output_file),
                            colClasses = "character")

  validate_dimensions_columns(colnames(outputs), output_file)

  parsed_outputs <- lapply(seq_len(nrow(outputs)), function(row_num) {
    row <- outputs[row_num, ]
    ## When reading csv in excel the header column is included in count
    csv_row_num <- row_num + 1
    validate_and_parse_output(as.list(row), output_file, csv_row_num)
  })

  initialise_r_memory <- vcapply(parsed_outputs, generate_initialise_r_memory)
  initialise_r_memory <- paste(initialise_r_memory, collapse = "\n")
  set_r_dimensions <- vcapply(parsed_outputs, generate_set_r_dimensions)
  set_r_dimensions <- paste(set_r_dimensions, collapse = "\n")
  copy_data <- vcapply(parsed_outputs, generate_copy_data)
  copy_data <- paste(copy_data, collapse = "\n")
  return_output <- vcapply(parsed_outputs, generate_return)
  return_output <- paste0("  List ret = ListBuilder()\n",
                          paste(return_output, collapse = "\n"),
                          ";\n",
                          "  return ret;")
  header <- paste0(
    "// Generated by frogger: do not edit by hand\n",
    "// This file is automatically generated. Do not edit this file. If you ",
    "want to make changes\n// edit `model_output.hpp.in` and run ",
    "`./scripts/generate` to regenerate.")
  unpack_state_space <- generate_unpack_state_space()

  generated_code <- generate_cpp(template)
  writeLines(generated_code, dest)
  invisible(dest)
}

generate_initialise_r_memory <- function(output) {
  dimensions <- paste(output$parsed_dims, collapse = " * ")
  sprintf("  Rcpp::NumericVector r_%s(%s);", output$r_name, dimensions)
}

generate_set_r_dimensions <- function(output) {
  dimensions <- paste(output$parsed_dims, collapse = ", ")
  sprintf("  r_%s.attr(\"dim\") = Rcpp::NumericVector::create(%s);",
          output$r_name, dimensions)
}

generate_copy_data <- function(output) {
  sprintf("  std::copy_n(state.%s.data(), state.%s.size(), %s(r_%s));",
          output$cpp_name, output$cpp_name, output$r_type,
          output$r_name)
}

generate_return <- function(output) {
  dimensions <- paste(output$parsed_dims, collapse = ", ")
  sprintf("    .add(\"%s\", r_%s)",
          output$r_name, output$r_name)
}


#' Generate C++ for passing input data in model fit
#'
#' This generates using metadata from `src/model_inputs.yml`
#'
#' @param dest The destination to write generated code to.
#' @param input_csv Path to the csv of model inputs.
#'
#' @return Nothing, called to generate code in src dir
#' @keywords internal
generate_input_interface <- function(
    dest, input_csv = frogger_file("cpp_generation/model_input.csv")) {

  template <- readLines(frogger_file("cpp_generation/model_input.hpp.in"))
  input_file <- basename(input_csv)
  inputs <- utils::read.csv(input_csv, colClasses = "character")

  validate_dimensions_columns(colnames(inputs), input_file)

  parsed_inputs <- lapply(seq_len(nrow(inputs)), function(row_num) {
    row <- inputs[row_num, ]
    ## When reading csv in excel the header column is included in count
    csv_row_num <- row_num + 1
    validate_and_parse_input(as.list(row), input_file, csv_row_num)
  })

  from_r <- vlapply(parsed_inputs, function(input) {
    is_set(input$r_name)
  })
  from_value <- parsed_inputs[!from_r]
  from_r <- parsed_inputs[from_r]

  r_parse_data <- vcapply(from_r, generate_input_from_r)
  value_data <- vcapply(from_value, generate_input_from_value)
  parse_data <- paste(c(r_parse_data, value_data), collapse = "\n")
  header <- paste0(
    "// Generated by frogger: do not edit by hand\n",
    "// This file is automatically generated. Do not edit this file. If you ",
    "want to make changes\n// edit `model_input.hpp.in` and run ",
    "`./scripts/generate` to regenerate.")
  unpack_state_space <- generate_unpack_state_space()

  generated_code <- generate_cpp(template)
  writeLines(generated_code, dest)
  invisible(dest)
}

validate_and_parse_input <- function(input, filename, row_num) {
  row_text <- paste("row: ", row_num)
  assert_only_one_set(input, c("r_name", "value"),
                      name = row_text)
  assert_set(input$cpp_name, paste(row_text, "and col: cpp_name"))
  assert_enum(input$type, c("real_type", "int"),
              name = paste(row_text, "and col: type"))
  assert_enum(input$convert_base, c("FALSE", "TRUE", ""),
              name = paste(row_text, "and col: convert_base"))
  input$convert_base <- identical(input$convert_base, "TRUE")
  assert_set(input$dims)
  input$parsed_dims <- validate_and_parse_dims(input, filename, row_num)
  input
}

validate_and_parse_output <- function(output, filename, row_num) {
  row_text <- paste("row: ", row_num)
  assert_set(output$r_name)
  assert_set(output$cpp_name)
  assert_enum(output$r_type, c("REAL", "INTEGER"),
              name = paste(row_text, "and col: r_type"))
  assert_set(output$dims)
  output$parsed_dims <- validate_and_parse_dims(output, filename, row_num)
  output
}

generate_input_from_r <- function(input) {
  dimensions <- paste(input$parsed_dims, collapse = ", ")
  if (input$dims == 1 && dimensions[1] == 1) {
    return(generate_length1_input(input))
  }
  lhs <- sprintf("  const leapfrog::TensorMap%s<%s> %s",
                 input$dims, input$type, input$cpp_name)
  rhs <- sprintf("parse_data<%s>(data, \"%s\", %s)",
                 input$type, input$r_name, dimensions)
  if (!is.null(input$convert_base) && input$convert_base) {
    rhs <- sprintf("convert_base<%s>(%s)", input$dims, rhs)
  }
  paste0(lhs, " = ", rhs, ";")
}

generate_length1_input <- function(input) {
  sprintf("  const %s %s = Rcpp::as<%s>(data[\"%s\"])",
          input$type, input$cpp_name, input$type, input$r_name)
}

generate_input_from_value <- function(input) {
  dimensions <- paste(input$parsed_dims, collapse = ", ")
  declaration <- sprintf("  leapfrog::Tensor%s<%s> %s(%s);",
                         input$dims, input$type, input$cpp_name,
                         input$parsed_dims)
  set_value <- sprintf("  %s.setConstant(%s);",
                       input$cpp_name, input$value)
  paste0(declaration, "\n", set_value)
}

get_state_space_variables <- function() {
  c("NS", "pAG", "hAG", "hDS", "hTS", "hc1DS", "hc2DS", "hTM")
}

generate_unpack_state_space <- function() {
  state_space_vars <- get_state_space_variables()
  unpack_state_space <- vcapply(state_space_vars, function(var) {
    sprintf("  constexpr int %s = ss.%s;", var, var)
  })
  paste(unpack_state_space, collapse = "\n")
}

validate_dimensions_columns <- function(columns, filename) {
  dims_col <- which(columns == "dims")
  ## All columns after "dims" must be named dim1, dim2, .., dimi, etc.
  dimension_data <- columns[seq(dims_col + 1, length(columns))]
  invalid_columns <- !grepl("dim\\d", dimension_data)
  if (any(invalid_columns)) {
    invalid_column_names <- dimension_data[invalid_columns]
    stop(sprintf(paste("All columns after 'dims' must be a dimension",
                       "column, got %s. Check '%s'."),
                 format_vector(invalid_column_names), filename))
  }
  invisible(TRUE)
}

validate_and_parse_dims <- function(data, filename, row_num) {
  dims_col <- which(names(data) == "dims")
  dims <- data$dims

  ## We've validated already dimension columns come after the dims column
  ## e.g. csv has col1, col2, col3, ..., dims, dim1, dim2, dim3, ..., dimn
  ## dims are valid if they have same number set as specified in `dim` column
  set_dims <- vlapply(data[seq(dims_col + 1, length(data))], is_set)
  if (!identical(as.character(sum(set_dims)), dims)) {
    stop(sprintf("Expected %s dimensions for row %s but got %s, check '%s'.",
                 dims, row_num, sum(set_dims), filename))
  }
  ## also invalid if they are not set in order i.e. if dim3 is set,
  ## dim2 and dim1 must be we don't allow dim1 to be set, dim2 empty and
  ## dim3 set. We could allow this but I expect if we get this in the csv
  ## it is indicative of something being specified incorrectly so I want
  ## to error
  last_set <- max(which(set_dims))
  unset <- names(set_dims)[!set_dims[seq(1, last_set)]]
  if (length(unset) > 0) {
    stop(sprintf(paste("'%s' set in row %s but not %s, dimensions",
                        "must be set in order. Check '%s'."),
      names(set_dims)[last_set], row_num, format_vector(unset), filename))
  }
  as.character(data[seq(dims_col + 1, dims_col + last_set)])
}

generate_cpp <- function(template) {
  glue::glue(paste(template, collapse = "\n"),
             .open = "{{", .close = "}}",
             .envir = parent.frame())
}
