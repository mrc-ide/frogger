#' Generate C++ for passing output from model fit into R
#'
#' This generates using metadata from `src/model_output.yml`
#'
#' @param dest The destination to write generated code to.
#'
#' @return Nothing, called to generate code in src dir
#' @keywords internal
generate_output_interface <- function(dest) {

  template <- readLines(frogger_file("r_interface/model_output.hpp.in"))
  outputs <- yaml::read_yaml(
    frogger_file("r_interface/model_output.yml"))$outputs

  for (i in seq_along(outputs)) {
    assert_names(outputs[[i]],
                 c("r_name", "cpp_name", "r_type", "dimensions"),
                 NULL)
  }

  initialise_r_memory <- vcapply(outputs, generate_initialise_r_memory)
  initialise_r_memory <- paste(initialise_r_memory, collapse = "\n")
  set_r_dimensions <- vcapply(outputs, generate_set_r_dimensions)
  set_r_dimensions <- paste(set_r_dimensions, collapse = "\n")
  copy_data <- vcapply(outputs, generate_copy_data)
  copy_data <- paste(copy_data, collapse = "\n")
  return_output <- vcapply(outputs, generate_return)
  return_output <- paste0("return Rcpp::List::create(\n",
                          paste(return_output, collapse = ",\n"),
                          ");")
  header <- paste0(
    "// ========= DO NOT EDIT =========\n",
    "// This file is automatically generated. Do not edit this file. If you ",
    "want to make changes\n// edit `model_output.hpp.in` and run ",
    "`./scripts/generate` to regenerate.")

  generated_code <- glue::glue(paste(template, collapse = "\n"),
                               .open = "{{", .close = "}}")
  writeLines(generated_code, dest)
  invisible(TRUE)
}

generate_initialise_r_memory <- function(output) {
  dimensions <- paste(output$dimensions, collapse = " * ")
  sprintf("  Rcpp::NumericVector r_%s(%s);", output$r_name, dimensions)
}

generate_set_r_dimensions <- function(output) {
  dimensions <- paste(output$dimensions, collapse = ", ")
  sprintf("  r_%s.attr(\"dim\") = Rcpp::NumericVector::create(%s);",
          output$r_name, dimensions)
}

generate_copy_data <- function(output) {
  sprintf("  std::copy_n(state.%s.data(), state.%s.size(), %s(r_%s));",
          output$cpp_name, output$cpp_name, output$r_type,
          output$r_name)
}

generate_return <- function(output) {
  dimensions <- paste(output$dimensions, collapse = ", ")
  sprintf("    Rcpp::_[\"%s\"] = r_%s",
          output$r_name, output$r_name)
}


#' Generate C++ for passing input data in model fit
#'
#' This generates using metadata from `src/model_inputs.yml`
#'
#' @param dest The destination to write generated code to.
#'
#' @return Nothing, called to generate code in src dir
#' @keywords internal
generate_input_interface <- function(dest) {

  template <- readLines(frogger_file("r_interface/model_input.hpp.in"))
  inputs <- yaml::read_yaml(
    frogger_file("r_interface/model_input.yml"))$inputs

  for (i in seq_along(inputs)) {
    assert_names(inputs[[i]],
                 c("cpp_name", "type", "dimensions"),
                 c("r_name", "value", "convert_base"))
    assert_names_one_of(inputs[[i]], c("r_name", "value"))
  }

  from_r <- vlapply(inputs, function(input) "r_name" %in% names(input))
  from_value <- inputs[!from_r]
  from_r <- inputs[from_r]

  r_parse_data <- vcapply(from_r, generate_input_from_r)
  value_data <- vcapply(from_value, generate_input_from_value)
  parse_data <- paste(c(r_parse_data, value_data), collapse = "\n")
  header <- paste0(
    "// ========= DO NOT EDIT =========\n",
    "// This file is automatically generated. Do not edit this file. If you ",
    "want to make changes\n// edit `model_input.hpp.in` and run ",
    "`./scripts/generate` to regenerate.")

  generated_code <- glue::glue(paste(template, collapse = "\n"),
                               .open = "{{", .close = "}}")
  writeLines(generated_code, dest)
  invisible(TRUE)
}

generate_input_from_r <- function(input) {
  dimensions <- paste(input$dimensions, collapse = ", ")
  n_dims <- length(input$dimensions)
  lhs <- sprintf("  const leapfrog::TensorMap%s<%s> %s",
                 n_dims, input$type, input$cpp_name)
  rhs <- sprintf("parse_data<%s>(data, \"%s\", %s)",
                 input$type, input$r_name, dimensions)
  if (!is.null(input$convert_base) && input$convert_base) {
    rhs <- sprintf("convert_base<%s>(%s)", n_dims, rhs)
  }
  paste0(lhs, " = ", rhs, ";")
}

generate_input_from_value <- function(input) {
  dimensions <- paste(input$dimensions, collapse = ", ")
  n_dims <- length(input$dimensions)
  declaration <- sprintf("  leapfrog::Tensor%s<%s> %s(%s);",
                         n_dims, input$type, input$cpp_name, dimensions)
  set_value <- sprintf("  %s.setConstant(%s);",
                       input$cpp_name, input$value)
  paste0(declaration, "\n", set_value)
}
