{% include "header.j2" %}

#pragma once

#include "config.hpp"
#include "config_mixer.hpp"
#include "../options.hpp"

namespace leapfrog {
namespace internal {

template<bool enable, typename ConfigMixin, typename AdapterMixin>
struct Triple;

template<typename TripleT>
struct TripleToPair;

template<bool enable, typename ConfigMixin, typename AdapterMixin>
struct TripleToPair<Triple<enable, ConfigMixin, AdapterMixin>> {
  using type = Pair<enable, ConfigMixin>;
};

template<typename ...Ts>
struct AdapterMixer;

template<typename real_type, MV ModelVariant>
struct AdapterMixer<real_type, ModelVariant> {
  using Config = ConfigMixer<real_type, ModelVariant>;

  template<typename... Args>
  static typename Config::Pars get_pars(Args&&... args) {
    typename Config::Pars p = {}; return p;
  }

  template<typename... Args>
  static int build_output(int index, const auto& state, Args&&... args) {
    return index;
  }
};

template<typename real_type, MV ModelVariant, typename ConfigMixin, typename AdapterMixin, typename ...Ts>
struct AdapterMixer<real_type, ModelVariant, Triple<false, ConfigMixin, AdapterMixin>, Ts...> : public AdapterMixer<real_type, ModelVariant, Ts...> {};

{% for config in configs +%}
template<typename real_type, MV ModelVariant, typename AdapterMixin, typename ...Ts>
struct AdapterMixer<real_type, ModelVariant, Triple<true, {{ config.name }}Config<real_type, ModelVariant>, AdapterMixin>, Ts...> {
  using NextAdapterMixer = AdapterMixer<real_type, ModelVariant, Ts...>;
  using Config = ConfigMixer<real_type, ModelVariant, Pair<true, {{ config.name }}Config<real_type, ModelVariant>>, typename TripleToPair<Ts>::type...>;

  template<typename... Args>
  static typename Config::Pars get_pars(Args&&... args) {
    typename Config::Pars p = {
      NextAdapterMixer::get_pars(std::forward<Args>(args)...),
      AdapterMixin::get_pars(std::forward<Args>(args)...)
    };
    return p;
  }

  template<typename... Args>
  static int build_output(int index, const auto& state, Args&&... args) {
    int new_index = AdapterMixin::build_output(index, state.{{ config.namespace }}, std::forward<Args>(args)...);
    return NextAdapterMixer::build_output(new_index, state, std::forward<Args>(args)...);
  }
};
{% endfor %}

} // namespace internal
} // namespace leapfrog
