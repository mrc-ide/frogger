test_that("can generate output parsing", {
  t <- tempfile()
  generate_output_interface(t)

  result <- readLines(t)
  expect_true(any(grepl("// Generated by frogger: do not edit by hand", result)))
  expect_true(any(grepl(paste0(
    "Rcpp::NumericVector r_p_total_pop",
    "\\(base.pAG \\* base.NS \\* output_years\\);"),
    result)))
  expect_true(any(grepl(paste0(
    "r_p_total_pop\\.attr\\(\\\"dim\\\"\\) = Rcpp::NumericVector::",
    "create\\(base.pAG, base.NS, output_years\\);"),
    result)))
  expect_true(any(grepl(paste0(
    "std::copy_n\\(state\\.base\\.p_total_pop\\.data\\(\\), ",
    "state\\.base\\.p_total_pop.size\\(\\), REAL\\(r_p_total_pop\\)\\);"),
    result)))
  expect_true(any(grepl(
    "names\\[0\\] = \\\"p_total_pop\\\";",
    result)))
  expect_true(any(grepl(
    "ret\\[0\\] = r_p_total_pop;",
    result)))
})

test_that("can generate input parsing", {
  t <- tempfile()
  generate_input_interface(t)

  result <- readLines(t)
  expect_true(any(grepl("// Generated by frogger: do not edit by hand", result)))
  expect_true(any(grepl(paste0(
    "const leapfrog::TensorMap2<real_type> base_pop = parse_data<real_type>",
    "\\(data, \"basepop\", base.pAG, base.NS\\);"),
    result)))
  expect_true(any(grepl(paste0(
    "const leapfrog::Tensor1<int> idx_hm_elig = convert_base<1>\\(",
    "parse_data<int>\\(data, \"artcd4elig_idx\", proj_years \\+ 1\\)\\);"),
    result)))
  expect_true(any(grepl(
    "leapfrog::Tensor1<real_type> h_art_stage_dur\\(base.hTS - 1\\);",
    result)))
  expect_true(any(grepl(
    "h_art_stage_dur.setConstant\\(0.5\\);",
    result)))
  expect_true(any(grepl(
    "const leapfrog::Demography<real_type> demography = {",
    result)))
  expect_true(any(grepl(
    "const leapfrog::Children<real_type> child = {",
    result)))
})

test_that("generated files are up to date", {
  target_input_file <- frogger_file("include/model_input.hpp")
  t_input <- tempfile()
  generate_input_interface(t_input)
  expect_identical(
    readLines(t_input), readLines(target_input_file),
    info = paste0("Your interface is out of date, regenerate by running ",
                  "./scripts/generate")
  )

  target_output_file <- frogger_file("include/model_output.hpp")
  t_output <- tempfile()
  generate_output_interface(t_output)
  expect_identical(
    readLines(t_output), readLines(target_output_file),
    info = paste0("Your interface is out of date, regenerate by running ",
                  "./scripts/generate")
  )
})

test_that("validate_and_parse_dims", {
  row <- data.frame(r_name = "basepop", cpp_name = "base_pop",
                    type = "real_type", dims = "2", dim1 = "pAG",
                    dim2 = "NS", dim3 = "", dim4 = NA_character_)
  expect_equal(validate_and_parse_dims(row, "inputs.csv", 4),
               c("pAG", "NS"))


  row$dim3 <- "proj_years"
  expect_error(
    validate_and_parse_dims(row, "inputs.csv", 4),
    "Expected 2 dimensions for row 4 but got 3, check 'inputs.csv'.")

  row$dim2 <- ""
  expect_error(
    validate_and_parse_dims(row, "inputs.csv", 4),
    paste0("'dim3' set in row 4 but not 'dim2', dimensions must ",
           "be set in order. Check 'inputs.csv'."))

  row$dim3 <- ""
  row$dim4 <- "proj_years"
  expect_error(
    validate_and_parse_dims(row, "inputs.csv", 4),
    paste0("'dim4' set in row 4 but not 'dim2', 'dim3', dimensions must ",
           "be set in order. Check 'inputs.csv'."))
})

test_that("csv structure can be validated", {
  colnames <- c("r_name", "cpp_name", "dims", "dim1", "dim2")
  expect_silent(validate_dimensions_columns(colnames, "inputs.csv"))

  colnames <- c(colnames, "other")
  expect_error(
    validate_dimensions_columns(colnames, "inputs.csv"),
    paste("All columns after 'dims' must be a dimension column, got 'other'.",
          "Check 'inputs.csv'."))
})

test_that("can generate length 1 inputs", {
  input <- utils::read.csv(frogger_file("cpp_generation/model_input.csv"))
  length_1_input <- data.frame(r_name = "len1", cpp_name = "len_1",
                               type = "real_type", input_when = "",
                               value = NA_character_,
                               convert_base = FALSE, dims = 1, dim1 = 1,
                               dim2 = "", dim3 = "", dim4 = "")
  input <- rbind.data.frame(input, length_1_input)
  t_input <- tempfile()
  write.csv(input, t_input)
  t_dest <- tempfile()

  generate_input_interface(t_dest, t_input)
  result <- readLines(t_dest)
  expect_true(any(grepl(
    "const real_type len_1 = Rcpp::as<real_type>\\(data\\[\"len1\"\\]\\)",
    result)))
})

test_that("output optional data generated in conditional block", {
  t <- tempfile()
  generate_output_interface(t)

  result <- readLines(t)

  opening_condition <- which(grepl(
    "if constexpr \\([A-Za-z:_]+\\) \\{",
    result))[1]
  closing <- which(grepl("^\\s+\\}$", result))

  closing_bracket <- closing[closing > opening_condition][1]

  optional_data <- which(grepl(paste0(
    "Rcpp::NumericVector r_hc1_hiv_pop\\(children.hc1DS ",
    "\\* children.hcTT \\* children.hc1AG \\* base.NS \\* output_years\\);"),
    result))
  expect_true(optional_data > opening_condition)
  expect_true(optional_data < closing_bracket)
})

test_that("input optional data generated in conditional block", {
  t <- tempfile()
  generate_input_interface(t)

  result <- readLines(t)

  opening_condition <- which(grepl(
    "if constexpr \\([A-Za-z:_]+\\) \\{",
    result))[1]
  else_statement <- which(grepl("^\\s+\\} else \\{$", result))[1]
  closing <- which(grepl("^\\s+\\}$", result))

  closing_bracket <- closing[closing > opening_condition][1]

  optional_data <- which(grepl(paste0(
    "const leapfrog::TensorMap1<real_type> hc_nosocomial =",
    " parse_data<real_type>\\(data, \"paed_incid_input\", proj_years\\);"),
    result))
  expect_true(optional_data > opening_condition)
  expect_true(optional_data < else_statement)
})

test_that("camel_to_snake works", {
  expect_equal(camel_to_snake(""), "")
  expect_equal(camel_to_snake("Art"), "art")
  expect_equal(camel_to_snake("NaturalHistory"), "natural_history")
  expect_equal(camel_to_snake("MyLongString"), "my_long_string")
  expect_equal(camel_to_snake("ART"), "a_r_t")
  expect_equal(camel_to_snake("MYString"), "m_y_string")
  expect_equal(camel_to_snake("myString"), "my_string")
  expect_equal(camel_to_snake("childART"), "child_a_r_t")
})

test_that("can generate parameter types", {
  t <- tempfile()
  generate_parameter_types(t)

  result <- readLines(t)
  expect_true(any(grepl("// Generated by frogger: do not edit by hand", result)))
  expect_true(any(grepl(paste0(
    "struct Demography {",
    "  TensorMap2<real_type> base_pop;"),
    result)))
  expect_true(any(grepl("real_type ctx_effect;", result)))
  expect_true(any(grepl("  TensorMap1<int> hc_art_isperc;", result)))
  expect_true(any(grepl("  int scale_cd4_mortality;", result)))
  expect_true(any(grepl("  Tensor1<int> idx_hm_elig;", result)))
})
