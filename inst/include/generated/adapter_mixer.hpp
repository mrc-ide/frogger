// Generated by cpp_generation: do not edit by hand
// This file is automatically generated. Do not edit this file. If you want to make changes
// edit json files in `cpp_generation/modelSchemas` and run `uv run ./src/main.py` inside
// the `cpp_generation` folder.

#pragma once

#include "./adapter.hpp"

namespace leapfrog {
namespace internal {

template<Language L, typename ...Ts>
struct AdapterMixer;

template<Language L, typename real_type, MV ModelVariant>
struct AdapterMixer<L, real_type, ModelVariant> {
  using Config = ConfigMixer<real_type, ModelVariant>;

  template<typename... Args>
  static typename Config::Pars get_pars(Args&&... args) {
    typename Config::Pars p = {}; return p;
  }

  template<typename... Args>
  static int build_output(int index, const auto& state, Args&&... args) {
    return index;
  }
};

template<Language L, typename real_type, MV ModelVariant, typename AdapterMixin, typename ...Ts>
struct AdapterMixer<L, real_type, ModelVariant, Pair<false, AdapterMixin>, Ts...> : public AdapterMixer<L, real_type, ModelVariant, Ts...> {};


template<Language L, typename real_type, MV ModelVariant, typename ...Ts>
struct AdapterMixer<L, real_type, ModelVariant, Pair<true, DpAdapter<L, real_type, ModelVariant>>, Ts...> {
  using NextAdapterMixer = AdapterMixer<L, real_type, ModelVariant, Ts...>;
  using AdapterMixin = DpAdapter<L, real_type, ModelVariant>;
  using Pars = Config<real_type, ModelVariant>::PartialPars::DpPars;

  template<typename... Args>
  static Pars get_pars(Args&&... args) {
    Pars p = {
      NextAdapterMixer::get_pars(std::forward<Args>(args)...),
      AdapterMixin::get_pars(std::forward<Args>(args)...)
    };
    return p;
  }

  template<typename... Args>
  static int build_output(int index, const auto& state, Args&&... args) {
    int new_index = AdapterMixin::build_output(index, state.dp, std::forward<Args>(args)...);
    return NextAdapterMixer::build_output(new_index, state, std::forward<Args>(args)...);
  }
};

template<Language L, typename real_type, MV ModelVariant, typename ...Ts>
struct AdapterMixer<L, real_type, ModelVariant, Pair<true, HaAdapter<L, real_type, ModelVariant>>, Ts...> {
  using NextAdapterMixer = AdapterMixer<L, real_type, ModelVariant, Ts...>;
  using AdapterMixin = HaAdapter<L, real_type, ModelVariant>;
  using Pars = Config<real_type, ModelVariant>::PartialPars::HaPars;

  template<typename... Args>
  static Pars get_pars(Args&&... args) {
    Pars p = {
      NextAdapterMixer::get_pars(std::forward<Args>(args)...),
      AdapterMixin::get_pars(std::forward<Args>(args)...)
    };
    return p;
  }

  template<typename... Args>
  static int build_output(int index, const auto& state, Args&&... args) {
    int new_index = AdapterMixin::build_output(index, state.ha, std::forward<Args>(args)...);
    return NextAdapterMixer::build_output(new_index, state, std::forward<Args>(args)...);
  }
};

template<Language L, typename real_type, MV ModelVariant, typename ...Ts>
struct AdapterMixer<L, real_type, ModelVariant, Pair<true, HcAdapter<L, real_type, ModelVariant>>, Ts...> {
  using NextAdapterMixer = AdapterMixer<L, real_type, ModelVariant, Ts...>;
  using AdapterMixin = HcAdapter<L, real_type, ModelVariant>;
  using Pars = Config<real_type, ModelVariant>::PartialPars::HcPars;

  template<typename... Args>
  static Pars get_pars(Args&&... args) {
    Pars p = {
      NextAdapterMixer::get_pars(std::forward<Args>(args)...),
      AdapterMixin::get_pars(std::forward<Args>(args)...)
    };
    return p;
  }

  template<typename... Args>
  static int build_output(int index, const auto& state, Args&&... args) {
    int new_index = AdapterMixin::build_output(index, state.hc, std::forward<Args>(args)...);
    return NextAdapterMixer::build_output(new_index, state, std::forward<Args>(args)...);
  }
};


} // namespace internal

template<Language L, typename real_type, internal::MV ModelVariant>
using Adapter = internal::AdapterMixer<
  L, real_type, ModelVariant,
  internal::Pair<ModelVariant::run_demographic_projection, internal::DpAdapter<L, real_type, ModelVariant>>,
  internal::Pair<ModelVariant::run_hiv_simulation, internal::HaAdapter<L, real_type, ModelVariant>>,
  internal::Pair<ModelVariant::run_child_model, internal::HcAdapter<L, real_type, ModelVariant>>
>;

} // namespace leapfrog
