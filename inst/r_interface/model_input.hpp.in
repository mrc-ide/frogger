{{header}}

#pragma once

#include <Rcpp.h>
#include <unsupported/Eigen/CXX11/Tensor>

#include "types.hpp"

template <typename T>
T* r_data(SEXP x) {
  static_assert(sizeof(T) == 0, "Only specializations of r_data can be used");
}

template <>
double* r_data(SEXP x) {
  return REAL(x);
}

template <>
int * r_data(SEXP x) {
  return INTEGER(x);
}

template<typename T, typename... Args>
auto parse_data(const Rcpp::List data, const std::string& key, Args... dims) {
  constexpr std::size_t rank = sizeof...(dims);
  Eigen::array<int, rank> dimensions{ static_cast<int>(dims)... };

  int length = std::accumulate(dimensions.begin(), dimensions.end(), 1, std::multiplies<int>());
  SEXP array_data = data[key];
  // In cases where the input data has project years we might not use all of it model fit
  // So we can take create a Map over a smaller slice of the data
  // As long as this is true we can be confident we're not referencing invalid memory
  if (LENGTH(array_data) < length) {
    Rcpp::stop("Invalid size of data for '%s', expected %d got %d",
               key,
               length,
               LENGTH(array_data));
  }

  return Eigen::TensorMap<Eigen::Tensor<T, rank>>(r_data<T>(array_data), static_cast<int>(dims)...);
}

template<typename T, std::size_t rank>
auto convert_base(Eigen::TensorMap<Eigen::Tensor<int, rank>> map) {
  static_assert(sizeof(T) == 0, "Only specializations of convert_base can be used");
}

template<std::size_t rank>
auto convert_base(Eigen::TensorMap<Eigen::Tensor<double, rank>> map) {
  for (int i = 0; i < map.size(); ++i) {
    // 0-based indexing in C++ vs 1-based indexing in R
    map.data()[i] = map.data()[i] - 1.0f;
  }
  return map;
}

template<std::size_t rank>
auto convert_base(Eigen::TensorMap<Eigen::Tensor<int, rank>> map) {
  for (int i = 0; i < map.size(); ++i) {
    // 0-based indexing in C++ vs 1-based indexing in R
    map.data()[i] = map.data()[i] - 1;
  }
  return map;
}

template<leapfrog::HivAgeStratification S, typename real_type>
leapfrog::Parameters <real_type> setup_model_params(const Rcpp::List &data,
                                                    const leapfrog::Options<real_type> &options,
                                                    const int proj_years) {
  constexpr auto ss = leapfrog::StateSpace<S>();
  constexpr int num_genders = ss.num_genders;
  constexpr int age_groups_pop = ss.age_groups_pop;
  constexpr int age_groups_hiv = ss.age_groups_hiv;
  constexpr int disease_stages = ss.disease_stages;
  constexpr int treatment_stages = ss.treatment_stages;
  const int age_groups_fert = options.age_groups_fert;
  const int hiv_adult_first_age_group = options.hiv_adult_first_age_group;

{{parse_data}}

  const leapfrog::Demography<real_type> demography = {
      base_pop,
      survival,
      net_migration,
      age_sex_fertility_ratio,
      births_sex_prop
  };

  const leapfrog::Incidence<real_type> incidence = {
      incidence_rate,
      incidence_relative_risk_age,
      incidence_relative_risk_sex
  };

  const leapfrog::NaturalHistory<real_type> natural_history = {
      cd4_mortality,
      cd4_progression,
      cd4_initdist
  };

  const leapfrog::Art<real_type> art = {
      artcd4elig_idx,
      art_mortality,
      artmx_timerr,
      h_art_stage_dur,
      art_dropout,
      art15plus_num,
      art15plus_isperc
  };

  const leapfrog::Parameters<real_type> params = {options,
                                                  demography,
                                                  incidence,
                                                  natural_history,
                                                  art};
  return params;
}
